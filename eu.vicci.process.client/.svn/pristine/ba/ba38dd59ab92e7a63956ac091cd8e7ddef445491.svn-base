package eu.vicci.process.client;

import java.io.IOException;
import java.io.StringReader;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;
import org.eclipse.emf.ecore.xmi.impl.XMLResourceImpl;
import org.eclipse.emf.ecore.xmi.util.XMLProcessor;
import org.eclipse.graphiti.mm.pictograms.PictogramsPackage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.InputSource;

import eu.vicci.process.client.core.AbstractClientBuilder;
import eu.vicci.process.client.core.ClientProfile;
import eu.vicci.process.client.core.IProcessEngineClient;
import eu.vicci.process.client.handlers.AbstractClientHandler;
import eu.vicci.process.client.handlers.DeployInstanceHandler;
import eu.vicci.process.client.handlers.DeployModelHandler;
import eu.vicci.process.client.handlers.DeployProcessHandler;
import eu.vicci.process.client.handlers.ExecuteProcessStepHandler;
import eu.vicci.process.client.handlers.InstanceConfigurationHandler;
import eu.vicci.process.client.handlers.ModelListHandler;
import eu.vicci.process.client.handlers.PauseInstanceHandler;
import eu.vicci.process.client.handlers.ProcessDocumentHandler;
import eu.vicci.process.client.handlers.ProcessInfosHandler;
import eu.vicci.process.client.handlers.ProcessInstanceInfosHandler;
import eu.vicci.process.client.handlers.ProcessInstanceInfosReducedHandler;
import eu.vicci.process.client.handlers.ProcessInstanceListHandler;
import eu.vicci.process.client.handlers.ProcessListHandler;
import eu.vicci.process.client.handlers.RegisterClientHandler;
import eu.vicci.process.client.handlers.RemoveInstanceHandler;
import eu.vicci.process.client.handlers.ResumeInstanceHandler;
import eu.vicci.process.client.handlers.RetrieveInstanceLogHandler;
import eu.vicci.process.client.handlers.RetrieveInstanceStateHandler;
import eu.vicci.process.client.handlers.RetrieveRecentStateChangesHandler;
import eu.vicci.process.client.handlers.StartInstanceHandler;
import eu.vicci.process.client.handlers.StopInstanceHandler;
import eu.vicci.process.client.handlers.UploadAndDeployHandler;
import eu.vicci.process.client.handlers.UploadModelHandler;
import eu.vicci.process.client.subscribers.AbstractSubscriber;
import eu.vicci.process.client.subscribers.HumanTaskResponseSubscriber;
import eu.vicci.process.client.subscribers.WampMessageSubscriber;
import eu.vicci.process.client.subscribers.WampResponseSubscriper;
import eu.vicci.process.engine.core.ClientBuilderFactory;
import eu.vicci.process.engine.core.IProcessInfo;
import eu.vicci.process.engine.core.IProcessInstanceInfo;
import eu.vicci.process.model.sofia.Process;
import eu.vicci.process.model.sofia.ProcessStep;
import eu.vicci.process.model.sofia.SofiaPackage;
import eu.vicci.process.model.sofiainstance.DataTypeInstance;
import eu.vicci.process.model.sofiainstance.ProcessInstance;
import eu.vicci.process.model.sofiainstance.ProcessStepInstance;
import eu.vicci.process.model.sofiainstance.SofiaInstanceFactory;
import eu.vicci.process.model.sofiainstance.SofiaInstancePackage;
import eu.vicci.process.model.util.ConfigureInstanceRequest;
import eu.vicci.process.model.util.ExecuteProcessStepRequest;
import eu.vicci.process.model.util.ProcessStartRequest;
import eu.vicci.process.model.util.UploadModelRequest;
import eu.vicci.process.model.util.Utility;
import eu.vicci.process.model.util.configuration.RpcId;
import eu.vicci.process.model.util.configuration.TopicId;
import eu.vicci.process.model.util.messages.core.HumanTaskRequestListener;
import eu.vicci.process.model.util.messages.core.IHumanTaskRequest;
import eu.vicci.process.model.util.messages.core.IMessageReceiver;
import eu.vicci.process.model.util.messages.core.IStateChangeMessage;
import eu.vicci.process.model.util.messages.core.MessageType;
import eu.vicci.process.model.util.messages.core.StateChangeListener;
import eu.vicci.process.model.util.serialization.jsonprocessstepinstances.JSONProcessStepInstanceSerializer;
import eu.vicci.process.model.util.serialization.jsontypeinstances.JSONTypeInstanceSerializer;
import eu.vicci.process.model.util.serialization.jsontypeinstances.core.IJSONTypeInstance;
import ws.wamp.jawampa.PubSubData;
import ws.wamp.jawampa.WampClient;
import ws.wamp.jawampa.WampClientBuilder;
import ws.wamp.jawampa.connection.IWampConnectorProvider;
import ws.wamp.jawampa.transport.netty.NettyWampClientConnectorProvider;

/**
 * The Client can be used to upload, start etc. processes and receive their status updates.
 * It is also possible to register remote procedure calls on this client, which can be called from any other client (or the vicci runtime server).
 * This client implementation backs a {@link ws.wamp.jawampa.WampClient}.
 */
public class ProcessEngineClient implements IProcessEngineClient {
	private static final Logger logger = LoggerFactory.getLogger(ProcessEngineClient.class);

	// timeout in seconds for waiting till rpc call return result
	private static final int TIMEOUT = 120;

	private String uuid = UUID.randomUUID().toString();

	private String ip;
	private String port;
	private String name;
	private String namespace;
	private String realmName;
	private boolean isServer;
	private WampClient client;
	
	public static final String DEFAULT_REALM = "vicciRealm";
	public static final String DEFAULT_NAMESPACE = "vicciWs";

	/**
	 * Default constructor. For a more readable code you can use the {@link eu.vicci.process.client.ProcessEngineClientBuilder}.
	 * @param name
	 * @param ip
	 * @param port
	 * @param realmName
	 * @param namespace
	 * @param isServer
	 */
	public ProcessEngineClient(String name, String ip, String port, String realmName, String namespace,
			boolean isServer) {
		this.name = name;
		this.ip = ip;
		this.port = port;
		this.namespace = namespace;
		this.realmName = realmName;
		this.isServer = isServer;

		// Initialize the models
		SofiaPackage.eINSTANCE.eClass();
		SofiaInstancePackage.eINSTANCE.eClass();
		PictogramsPackage.eINSTANCE.eClass();

		Resource.Factory.Registry reg = Resource.Factory.Registry.INSTANCE;
		Map<String, Object> m = reg.getExtensionToFactoryMap();
		m.put("diagram", new XMIResourceFactoryImpl());
		m.put("sofia", new XMIResourceFactoryImpl());
		m.put("sofiainstance", new XMIResourceFactoryImpl());
	}

	/**
	 * Connects to the server. Returns, if the client is connected.
	 */
	@Override
	public boolean connect() {
		IWampConnectorProvider connectorProvider = new NettyWampClientConnectorProvider();
		WampClientBuilder builder = new WampClientBuilder();
		CountDownLatch waitTillConnected = new CountDownLatch(1);

		try {
			builder.withConnectorProvider(connectorProvider)
				.withUri("ws://" + ip + ":" + port + "/" + namespace)
				.withRealm(realmName)
				.withInfiniteReconnects()
				.withReconnectInterval(3, TimeUnit.SECONDS);
			client = builder.build();
			registerRpcHandlers(waitTillConnected);
			client.open();
			waitTillConnected.await(TIMEOUT, TimeUnit.SECONDS);
			return true;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return false;
	}

	private void registerRpcHandlers(final CountDownLatch waitTillConnected) {
		client.statusChanged().subscribe(state -> {
			if (!(state instanceof WampClient.ConnectedState))
				return;
			// register rpc handlers here if needed

			// at this point the client is connected and the method connect() should return true
			waitTillConnected.countDown();
		});

	}

	/**
	 * Registers this client with all its possible procedure ids by the server. The router in the
	 * Server handles all the connection stuff. Only possible procedure ids are needed, so that you
	 * know which rpc you can call on a specific client.
	 */
	@Override
	public String registerProcessExecutionClient() {
		RegisterClientHandler rch = new RegisterClientHandler();
		ClientProfile cp = new ClientProfile(name, uuid);
		cp.addTopic("printHello");

		client.registerProcedure(cp.getRpcBase() + "printHello").subscribe(request -> {
			System.out.println("#### This is a procedure which can be executed by some client ####");
		});

		// Register possible RPC here and add this to the client profile

		callRpc(RpcId.REGISTER_CLIENT, rch, cp);
		return rch.getState();
	}

	@Override
	public String getUuid() {
		return uuid;
	}

	@Override
	public String getIp() {
		return ip;
	}

	@Override
	public void setIp(String ip) {
		this.ip = ip;
	}

	@Override
	public String getPort() {
		return port;
	}

	@Override
	public void setPort(String port) {
		this.port = port;
	}

	@Override
	public boolean isServer() {
		return isServer;
	}

	@Override
	public void setServer(boolean server) {
		isServer = server;
	}

	@Override
	public void subscribeTo(String topic, MessageType messageType, IMessageReceiver receiver) {
		AbstractSubscriber<PubSubData> subscriber = null;
		//TODO responses are not needed by the client
		switch (messageType) {
		case WAMPMESSAGE:
			subscriber = new WampMessageSubscriber();
			break;
		case HUMANTASKRESPONSE:
			subscriber = new HumanTaskResponseSubscriber();
			break;
		case WAMPRESPONSE:
			subscriber = new WampResponseSubscriper();
			break;
		default:
			logger.error("the specified message type '{}' is not handled for subscription", messageType);
			return;
		}
		
		subscriber.setReceiver(receiver);
		subscriber.setTopicId(topic);
		client.makeSubscription(topic).subscribe(subscriber);	
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public void setName(String name) {
		this.name = name;
	}

	@Override
	public void publish(String topic, Object payload) {
		client.publish(topic, payload);
	}

	@Override
	public void publishHumanTask(IHumanTaskRequest payload) {
		publish(TopicId.HUMAN_TASK_REQ, payload);
	}

	/**
	 * Upload a process model document (either *.sofia or *.diagram)
	 */
	@Override
	public String uploadProcessDefinition(String processid, String processdocument, boolean isDiagram) {
		return uploadProcessDefinition(processid, processdocument, isDiagram, false);
	}

	@Override
	public String uploadProcessDefinition(String processid, String processdocument, boolean isDiagram,
			boolean overrideExisting) {
		// Reduce process document, i.e. delete graphical information
		if (isDiagram) {
			Process model = getProcessFromDocument(processdocument);
			processdocument = getProcessAsString(model, null);
			isDiagram = false;
		}

		byte[] compressed = Utility.compress(processdocument);

		UploadModelRequest input = new UploadModelRequest(processid, compressed, isDiagram, overrideExisting);
		UploadModelHandler umh = new UploadModelHandler();
		callRpc(RpcId.UPLOAD_MODEL, umh, input);
		String state = umh.getState();
		return state;
	}

	/**
	 * Calls the given RPC and waits till its finished
	 * 
	 * @param rpcId
	 * @param receiver
	 * @param payload
	 */
	private void callRpc(String rpcId, AbstractClientHandler receiver, Object payload) {
		CountDownLatch waitTillFinished = new CountDownLatch(1);
		receiver.addCountDownLatch(waitTillFinished);
		if (payload == null)
			client.call(rpcId).subscribe(receiver);
		else
			client.call(rpcId, payload).subscribe(receiver);

		try {
			waitTillFinished.await(TIMEOUT, TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			logger.error("Timeout while waiting for replay for rpc: '{}'", rpcId);
		}
	}

	private void callRpc(String rpcId, AbstractClientHandler receiver) {
		callRpc(rpcId, receiver);
	}

	@Override
	public String uploadAndDeploy(Process process) {
		String text = getProcessAsString(process, null);
		System.out.println("Text: " + text);
		byte[] compressed = Utility.compress(text);

		UploadModelRequest input = new UploadModelRequest(process.getId(), compressed, false);
		UploadAndDeployHandler uadh = new UploadAndDeployHandler();
		callRpc(RpcId.UPLOAD_AND_DEPLOY, uadh, input);
		return uadh.getState();
	}

	@Override
	public String deployProcess(String processid) {
		DeployModelHandler dmh = new DeployModelHandler();
		callRpc(RpcId.DEPLOY_MODEL, dmh, processid);
		return dmh.getState();
	}

	@Override
	public String deployProcessInstance(String processId) {
		DeployInstanceHandler dih = new DeployInstanceHandler();
		callRpc(RpcId.DEPLOY_INSTANCE, dih, processId);
		System.out.println("Instance ID: " + dih.getInstanceId());
		return dih.getInstanceId();
	}

	@Override
	public String configureProcessInstance(String processInstanceId, String configuration) {
		InstanceConfigurationHandler ich = new InstanceConfigurationHandler();
		ConfigureInstanceRequest input = new ConfigureInstanceRequest(processInstanceId, configuration);
		callRpc(RpcId.INSTANCE_CONFIGURATION, ich, input);
		return ich.getState();
	}

	@Override
	public String startProcessInstance(String processInstanceId, String processId,
			Map<String, DataTypeInstance> inputParameters) {
		return startProcessInstance(processInstanceId, processId, inputParameters, false);
	}
	
	@Override
	public String startProcessInstance(String processInstanceId, String processId,
			Map<String, DataTypeInstance> inputParameters, boolean runInLoop) {
		//TODO run in loop
		StartInstanceHandler sih = new StartInstanceHandler();
		Map<String, IJSONTypeInstance> ports = new HashMap<String, IJSONTypeInstance>();

		if (inputParameters != null) {
			for (String dtId : inputParameters.keySet()) {
				DataTypeInstance dti = inputParameters.get(dtId);
				IJSONTypeInstance json = JSONTypeInstanceSerializer.makeJSONTypeInstance(dti);
				ports.put(dtId, json);
			}
		} else {
			ports = null;
		}

		ProcessStartRequest input = new ProcessStartRequest(processInstanceId, processId, ports, runInLoop);
		callRpc(RpcId.START_INSTANCE, sih, input);
		return null;
	}

	@Override
	public String stopProcessInstance(String processInstanceId) {
		StopInstanceHandler stih = new StopInstanceHandler();
		callRpc(RpcId.STOP_INSTANCE, stih, processInstanceId);
		return stih.getState();
	}

	@Override
	public String pauseProcessInstance(String processInstanceId) {
		PauseInstanceHandler pih = new PauseInstanceHandler();
		callRpc(RpcId.PAUSE_INSTANCE, pih, processInstanceId);
		return pih.getState();
	}

	@Override
	public String resumeProcessInstance(String processInstanceId) {
		ResumeInstanceHandler rih = new ResumeInstanceHandler();
		callRpc(RpcId.RESUME_INSTANCE, rih, processInstanceId);
		return rih.getState();
	}

	@Override
	public String getProcessDefinition(String processid) {
		ProcessDocumentHandler pdh = new ProcessDocumentHandler();
		callRpc(RpcId.PROCESS_DOC, pdh, processid);
		return pdh.getDocument();
	}

	@Override
	public List<String> listUploadedProcessDefinitions() {
		ModelListHandler mlh = new ModelListHandler();
		callRpc(RpcId.LIST_MODELS, mlh);
		return mlh.getModelList();
	}

	@Override
	public List<IProcessInfo> listDeployedProcesses() {
		ProcessListHandler plh = new ProcessListHandler();
		callRpc(RpcId.PROCESS_LIST, plh);
		return plh.getProcessInfos();
	}

	@Override
	public Process getProcessInfos(String processId) {
		ProcessInfosHandler pih = new ProcessInfosHandler();
		callRpc(RpcId.PROCESS_INFOS, pih, processId);
		return pih.getProcess();
	}

	@Override
	public ProcessInstance getProcessInstanceInfos(String processInstanceId) {
		ProcessInstanceInfosHandler piih = new ProcessInstanceInfosHandler();
		callRpc(RpcId.PROCESS_INSTANCE_INFOS, piih, processInstanceId);
		return piih.getProcessInstance();
	}

	@Override
	public Map<String, String> getProcessInstanceInfosReduced(String processInstanceId) {
		ProcessInstanceInfosReducedHandler piirh = new ProcessInstanceInfosReducedHandler();
		callRpc(RpcId.PROCESS_INSTANCE_INFOS_REDUCED, piirh, processInstanceId);
		return piirh.getProcessStepInstances();
	}

	@Override
	public List<IProcessInstanceInfo> listProcessInstances() {
		ProcessInstanceListHandler pilh = new ProcessInstanceListHandler();
		callRpc(RpcId.PROCESS_INSTANCE_LIST, pilh);
		return pilh.getProcessInstanceList();
	}

	@Override
	public String uploadModelFile(String filepath) {
		Process model = null;

		// Obtain a new resource set
		ResourceSet resSet = new ResourceSetImpl();

		// Get the resource
		Resource resource = resSet.getResource(org.eclipse.emf.common.util.URI.createURI(filepath), true);

		// Get the first model element and cast it to the right type
		if (filepath.endsWith(".diagram")) {
			model = (Process) resource.getContents().get(1);
			// Obtain a new resource set
		} else {
			model = (Process) resource.getContents().get(0);
		}

		String modelId = model.getId();
		String text = getProcessAsString(model, null);
		System.out.println("Text: " + text);

		byte[] compressed = Utility.compress(text);

		UploadModelRequest input = new UploadModelRequest(modelId, compressed, false);
		UploadModelHandler umh = new UploadModelHandler();
		callRpc(RpcId.UPLOAD_MODEL, umh, input);
		return modelId;
	}

	@Override
	public String deployProcess(Process process) {
		String text = getProcessAsString(process, null);
		String processId = process.getId();

		System.out.println("Text: " + text);
		byte[] compressed = Utility.compress(text);

		UploadModelRequest input = new UploadModelRequest(processId, compressed, false);
		DeployProcessHandler dmh = new DeployProcessHandler();
		callRpc(RpcId.DEPLOY_PROCESS, dmh, input);
		return processId;
	}

	@Override
	public String removeInstance(String processInstanceId) {
		RemoveInstanceHandler rih = new RemoveInstanceHandler();
		callRpc(RpcId.REMOVE_INSTANCE, rih, processInstanceId);
		return rih.getState();
	}

	@Override
	public IStateChangeMessage getInstanceState(String processInstanceId) {
		RetrieveInstanceStateHandler rish = new RetrieveInstanceStateHandler();
		callRpc(RpcId.INSTANCE_STATE, rish, processInstanceId);
		return rish.getScm();
	}

	@Override
	public List<IStateChangeMessage> getInstanceLog(String processInstanceId) {
		RetrieveInstanceLogHandler rilh = new RetrieveInstanceLogHandler();
		callRpc(RpcId.INSTANCE_LOG, rilh, processInstanceId);
		return rilh.getInstanceLog();
	}

	@Override
	public List<IStateChangeMessage> getRecentStateChanges() {
		RetrieveRecentStateChangesHandler rrsch = new RetrieveRecentStateChangesHandler();
		callRpc(RpcId.RECENT_STATE_CHANGES, rrsch);
		return rrsch.getRecentStateChanges();
	}

	@Override
	public ProcessStepInstance executeProcessStep(ProcessStepInstance psi, ProcessStep ps, boolean alreadyExecuting) {
		if (alreadyExecuting)
			return null;
		String text1 = "";
		XMLProcessor processor = new XMLProcessor();
		Resource res = ps.eResource();

		try {
			text1 = processor.saveToString(res, Collections.EMPTY_MAP);
		} catch (IOException e2) {
			e2.printStackTrace();
		}

		String processInstanceString = JSONProcessStepInstanceSerializer.serialize(psi);
		ExecuteProcessStepRequest epr = new ExecuteProcessStepRequest();
		epr.setProcessStepInstance(processInstanceString);
		epr.setProcessStepModel(text1);
		ExecuteProcessStepHandler epsh = new ExecuteProcessStepHandler();

		callRpc(RpcId.EXECUTE_PROCESSSTEP, epsh, epr);

		String psiReturnString = epsh.getProcessInstanceString();
		ProcessStepInstance psiReturn = JSONProcessStepInstanceSerializer.deserialize(psiReturnString, SofiaInstanceFactory.eINSTANCE);
		return psiReturn;
	}

	@Override
	public void close() {
		client.close().toBlocking().last();
	}
	
	@Override
	public void setClientBuilderFactory(ClientBuilderFactory factory) {
		//not interested on this method for client		
	}

	@Override
	public AbstractClientBuilder createNewClientBuilder() {
		//not interested on this method for client	
		return null;
	}
	
	@Override
	public void loadExistingModels() {
		//not interested in this at the moment		
	}

	@Override
	public Map<String, String> getUploadedProcesses() {
		//not interested in this at the moment
		return null;
	}
	
	@Override
	public void addStateChangeListener(StateChangeListener stateChangeListener) {
		//use subscribe		
	}

	@Override
	public void removeStateChangeListener(StateChangeListener stateChangeListener) {
		//use subscribe
	}
	
	@Override
	public void addHumanTaskRequestListener(HumanTaskRequestListener humanTaskRequestListener) {
		//use subscribe	
		
	}

	@Override
	public void removeHumanTaskRequestListener(HumanTaskRequestListener humanTaskRequestListener) {
		//use subscribe	
		
	}
	
	private static String getProcessAsString(Process process, Map<?, ?> options) {
		String text = "";
		XMLResourceImpl resource = new XMLResourceImpl();
		XMLProcessor processor = new XMLProcessor();
		resource.getContents().add(process);

		try {
			text = processor.saveToString(resource, options);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return text;
	}
	
	private static Process getProcessFromDocument(String document){
		XMLResourceImpl res = new XMLResourceImpl();
		try {
			res.load(new InputSource(new StringReader(document)), null);
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		return (Process) res.getContents().get(1);		
	}
}
