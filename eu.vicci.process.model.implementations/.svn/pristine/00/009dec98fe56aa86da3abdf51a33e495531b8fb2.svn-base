package eu.vicci.process.model.sofiainstance.util.processstepclasses;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;

import org.glassfish.jersey.media.sse.EventListener;
import org.glassfish.jersey.media.sse.InboundEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;

import eu.vicci.process.devices.util.OpenHabEvent;
import eu.vicci.process.devices.util.Payload;
import eu.vicci.process.model.sofiainstance.DataTypeInstance;
import eu.vicci.process.openhab.util.OpenHabEventProvider;

/**
 * Same as {@link OpenHabWaitForEvent} but the first result which occurs will mapped to the
 * Datatypeinstances with name {@link #RESULT_TYPE}. This should also be present as a startdata
 * port, so that the correct datatype instance is committed as parameter.
 * 
 * Only for Demo purposes
 */
public class OpenHabWaitForEventWithResult implements ProcessStepWorker, EventListener {
	private static final Logger logger = LoggerFactory.getLogger(OpenHabWaitForEvent.class);
	private static final String serverType = "StepServerBasePath";
	private static final String RESULT_TYPE = "OpenHabResult";

	private Map<String, DataTypeInstance> itemsToWaitFor;
	private DataTypeInstance resultInstance;

	private List<DataTypeInstance> returnValues;

	private String uriBasePath;

	private CountDownLatch eventSignal;

	@Override
	public void deploy() {
	}

	@Override
	public List<DataTypeInstance> work(List<DataTypeInstance> parameter) {
		returnValues = new ArrayList<>();
		eventSignal = new CountDownLatch(1);

		setAllItemsToWaitForAndServerBasePath(parameter);
		setResultParamter(parameter);

		if (uriBasePath == null || uriBasePath.isEmpty())
			return returnValues;

		OpenHabEventProvider provider = new OpenHabEventProvider(uriBasePath);
		provider.registerToUpdates(this);

		try {
			eventSignal.await(); // avoids busy waiting and blocks till event was processed
		} catch (InterruptedException e) {
			logger.error("waiting for events was interrupted");
			e.printStackTrace();
		}
		provider.closeAllEventSources();
		return returnValues;
	}

	// EventListener Implementation
	// is synchronized necessary at this point, or provides this the
	// jersey/glassfish implementation?
	@Override
	public synchronized void onEvent(InboundEvent event) {
		if (!event.getName().equals("message"))
			return;
		Gson gson = new Gson();		
		OpenHabEvent ohEvent = gson.fromJson(event.readData(String.class), OpenHabEvent.class);
		Payload payload = gson.fromJson(ohEvent.getPayload(), Payload.class);
		String itemName = ohEvent.getItemName();

		if (!itemsToWaitFor.containsKey(itemName))
			return;
		// empty values are not recognized
		if (payload.getValue() == null || payload.getValue().isEmpty())
			return;
		DataTypeInstance instance = itemsToWaitFor.get(itemName);
		instance.parse(payload.getValue());
		returnValues.add(instance);
		if(resultInstance != null){
			resultInstance.parse(payload.getValue());
			returnValues.add(resultInstance);
		}
		eventSignal.countDown();
	}

//	private String getItemName(String topic) {
//		String name = topic.replace(OpenHabEventPrefixes.UPDATE, "");
//		if (name.startsWith("/"))
//			name = name.replaceFirst("\\/", "");
//		return name;
//	}

	private void setAllItemsToWaitForAndServerBasePath(List<DataTypeInstance> parameter) {
		itemsToWaitFor = new HashMap<String, DataTypeInstance>();
		for (DataTypeInstance dataTypeInstance : parameter) {
			String name = dataTypeInstance.getDataTypeType().getName();

			if (serverType.equals(name))
				uriBasePath = (String) dataTypeInstance.getValueAsObject();
			else
				itemsToWaitFor.put(name, dataTypeInstance);
		}
	}

	// For converting with gson
//	private class OpenHabUpdateEvent {
//		// event: message
//		// data:
//		// {"topic":"smarthome/update/TinkerforgeAmbientLight_2","object":"69.7"}
//		private String topic;
//		private String object;
//
//		public String getTopic() {
//			return topic;
//		}
//
//		public String getObject() {
//			return object;
//		}
//	}
	
	private void setResultParamter(List<DataTypeInstance> parameter) {
		Optional<DataTypeInstance> di = parameter.stream()
				.filter(d -> RESULT_TYPE.equals(d.getDataTypeType().getName()))
				.findFirst();	
		if(di.isPresent())
			resultInstance = di.get();
		else
			resultInstance = null; //is necessary cause it is not possible to reset this step
	}
}
